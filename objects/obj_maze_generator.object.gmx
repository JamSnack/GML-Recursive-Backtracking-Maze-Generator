<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Note that a cell is valid only if it lies within the bounds of the maze, 
AND it has not previously been visited: we only want to carve passages into 
untouched cells, to avoid creating circular loops in the maze.
*/


/*
    DESCRIBING THE PROCESSS:
1. First we want to fill up the room with tiles.
2. We want to carve a maze in those tiles using a Recursive Backtracing algorithm.
*/

randomize();

//Grid height and width are 0 indexed. This 10x10 maze's last column is 9.
maze_size = 32;
path_length = 2;
maze_grid = ds_grid_create(maze_size,maze_size);

//Set each cell in the grid to 1 to denote that something is there.
for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        ds_grid_set(maze_grid,i,f,1);
    }
}

//Initialize the carve - Must start at an odd point and move by 2.
carver_x = 1;
carver_y = 1;
check_next = true; //Whether or not to check the next direction.
backstep = false; //Whether or not to enable to backstepping routine.
directions_checked = ds_list_create(); //A list containing the checked directions of the carver during generation.
visited_cells_x = ds_list_create();
visited_cells_y = ds_list_create();

directions_x = ds_map_create();
ds_map_add(directions_x,"N",0);
ds_map_add(directions_x,"S",0);
ds_map_add(directions_x,"E",1);
ds_map_add(directions_x,"W",-1);

directions_y = ds_map_create();
ds_map_add(directions_y,"N",-1);
ds_map_add(directions_y,"S",1);
ds_map_add(directions_y,"E",0);
ds_map_add(directions_y,"W",0);

ds_list_add(visited_cells_x,carver_x);
ds_list_add(visited_cells_y,carver_y);

time = 0;
time_framerate = 10;

view_xview -= 32;
view_yview -= 32;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CARVE THE LABYRINTH!
//if (time mod time_framerate == 0) then exit;

//NOTE: When checking for grid coordinates, an invalid coordinate will also return 0.

//Select a random direction
var move_to = choose("N","S","W","E");

//Pick a new direction if the current direction is in the list.
if ds_list_find_index(directions_checked,move_to) != -1
{
    //If all directions checked, backstep. Otherwise find a new direction.
    if ds_list_size(directions_checked) &gt;= 4
    {
        ds_list_clear(directions_checked);
        
        if ds_list_size(visited_cells_x) &gt; 0
        {
            show_debug_message("MAZE GEN&gt; Entering backstep routine..");
            backstep = true;
            backstep_position = ds_list_size(visited_cells_x)-1;
        }
    }
    else
    {
        while(ds_list_find_index(directions_checked,move_to) != -1)
        {
            move_to = choose("N","S","W","E");
        }
    }
}

ds_list_add(directions_checked,move_to);

var next_x = carver_x+directions_x[? move_to]*path_length;
var next_y = carver_y+directions_y[? move_to]*path_length;

if move_to != undefined &amp;&amp; next_x &gt; 0 &amp;&amp; next_y &gt; 0 &amp;&amp; next_x &lt; maze_size-1 &amp;&amp; next_y &lt; maze_size-1 &amp;&amp; ds_grid_get(maze_grid,next_x,next_y) != 0
{
    maze_grid_update(move_to,path_length);
    backstep = false;
}

//BACKSTEP
if (backstep == true &amp;&amp; ds_list_size(visited_cells_x) &gt; 0)
{
    ds_list_delete(visited_cells_x,backstep_position);
    ds_list_delete(visited_cells_y,backstep_position);
    backstep_position -= 1;
    carver_x = ds_list_find_value(visited_cells_x,backstep_position);
    carver_y = ds_list_find_value(visited_cells_y,backstep_position);

    if backstep_position &lt;= 0
    {
        backstep = false;
        show_debug_message("BACKSTEP FAILED. MAZE COMPLETE?");
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_yview -= 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_yview += 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview += 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview -= 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        if ds_grid_get(maze_grid,f,i) == 1
        {
            draw_sprite(spr_black_tile,0,x+f*16,y+i*16);
        }
    }
}

draw_sprite(spr_player,0,carver_x*16,carver_y*16);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
