<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Note that a cell is valid only if it lies within the bounds of the maze, 
AND it has not previously been visited: we only want to carve passages into 
untouched cells, to avoid creating circular loops in the maze.
*/


/*
    DESCRIBING THE PROCESSS:
1. First we want to fill up the room with tiles.
2. We want to carve a maze in those tiles using a Recursive Backtracing algorithm.
*/

randomize();

//Grid height and width are 0 indexed. This 10x10 maze's last column is 9.
maze_size = 32;
maze_grid = ds_grid_create(maze_size,maze_size);

//Set each cell in the grid to 1 to denote that something is there.
for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        ds_grid_set(maze_grid,i,f,1);
    }
}

//Initialize the carve - Must start at an odd point and move by 2.
carver_x = 1;
carver_y = 1;
check_next = true; //Whether or not to check the next direction.
backstep = false; //Whether or not to enable to backstepping routine.
directions_checked = ds_list_create(); //A list containing the checked directions of the carver during generation.
visited_cells_x = ds_list_create();
visited_cells_y = ds_list_create();

ds_list_add(visited_cells_x,carver_x);
ds_list_add(visited_cells_y,carver_y);

time = 0;
time_framerate = 10;

view_xview -= 32;
view_yview -= 32;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CARVE THE LABYRINTH!
//if (time mod time_framerate == 0) then exit;

//NOTE: When checking for grid coordinates, an invalid coordinate will also return 0.

//Select a random direction
var move_to = choose("N","S","W","E");

//Pick a new direction if the current direction is in the list.
if ds_list_find_index(directions_checked,move_to) != -1
{
    //If all directions checked, backstep. Otherwise find a new direction.
    if ds_list_size(directions_checked) &gt;= 4
    {
        backstep = true;
        backstep_position = ds_list_size(visited_cells_x)-1;
        ds_list_clear(directions_checked);
        show_debug_message("MAZE GEN&gt; Entering backstep routine..");
    }
    else
    {
        while(ds_list_find_index(directions_checked,move_to) != -1)
        {
            move_to = choose("N","S","W","E");
        }
    }
}

ds_list_add(directions_checked,move_to);

switch move_to
{
    case "N":
    {
        //Check to see if the selected position is valid. Carve a path if so, otherwise check_next.
        if (carver_y-2 &gt; 0 &amp;&amp; ds_grid_get(maze_grid,carver_x,carver_y-2) != 0)
        {
            maze_grid_update("N",2);
        }
    }
    break;
    
    case "S":
    {
        //Check to see if the selected position is valid. Carve a path if so, otherwise check_next.
        if (carver_y+2 &lt; maze_size &amp;&amp; ds_grid_get(maze_grid,carver_x,carver_y+2) != 0)
        {
            maze_grid_update("S",2);
        }
    }
    break;
    
    case "E":
    {
        //Check to see if the selected position is valid. Carve a path if so, otherwise check_next.
        if (carver_x+2 &lt; maze_size &amp;&amp; ds_grid_get(maze_grid,carver_x+2,carver_y) != 0)
        {
            maze_grid_update("E",2);
        }
    }
    break;
    
    case "W":
    {
        //Check to see if the selected position is valid. Carve a path if so, otherwise check_next.
        if (carver_x-2 &gt; 0 &amp;&amp; ds_grid_get(maze_grid,carver_x-2,carver_y) != 0)
        {
            maze_grid_update("W",2);
        }
    }
    break;
}

//BACKSTEP
if (backstep == true)
{
    ds_list_delete(visited_cells_x,backstep_position);
    ds_list_delete(visited_cells_y,backstep_position);
    backstep_position -= 1;
    carver_x = ds_list_find_value(visited_cells_x,backstep_position);
    carver_y = ds_list_find_value(visited_cells_y,backstep_position);

    if backstep_position &lt;= 0
    {
        backstep = false;
        show_debug_message("BACKSTEP FAILED. MAZE COMPLETE?");
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_yview -= 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_yview += 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview += 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="65">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview -= 12;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>for(i=0;i&lt;maze_size;i++)
{
    for(f=0;f&lt;maze_size;f++)
    {
        if ds_grid_get(maze_grid,f,i) == 1
        {
            draw_sprite(spr_black_tile,0,x+f*16,y+i*16);
        }
    }
}

draw_sprite(spr_player,0,carver_x*16,carver_y*16);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>game_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
